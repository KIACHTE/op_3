#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "task.h"
#include "queue.h"

TaskQueue t_queue;
ResultStore r_store;
int next_id = 1;
pthread_mutex_t id_lock = PTHREAD_MUTEX_INITIALIZER;

// Task Processing Functions [cite: 16-18]
void process_task(task t) {
    char result_buf[256];
    if (t.type == 1) { // Reverse String [cite: 20-22]
        int len = strlen(t.payload);
        for(int i=0; i<len; i++) result_buf[i] = t.payload[len-1-i];
        result_buf[len] = '\0';
    } else if (t.type == 2) { // Sum List [cite: 23-25]
        int sum = 0, val;
        char *p = t.payload;
        while (sscanf(p, "%d", &val) == 1) {
            sum += val;
            while (*p && *p != ' ') p++;
            while (*p == ' ') p++;
        }
        sprintf(result_buf, "%d", sum);
    } else if (t.type == 3) { // Fibonacci [cite: 26-28]
        int n = atoi(t.payload);
        long long a=0, b=1, next;
        for(int i=0; i<n; i++) { next=a+b; a=b; b=next; }
        sprintf(result_buf, "%lld", a);
    }
    store_result(&r_store, t.id, result_buf);
}

void* worker_thread(void* arg) {
    while(1) {
        task t = dequeue(&t_queue);
        process_task(t);
        free(t.payload);
    }
    return NULL;
}

// RPC Handlers
int * submit_task_1_svc(task *argp, struct svc_req *rqstp) {
    static int result;
    pthread_mutex_lock(&id_lock);
    result = next_id++; [cite: 54]
    pthread_mutex_unlock(&id_lock);
    argp->id = result;
    enqueue(&t_queue, *argp);
    return &result;
}

result * get_result_1_svc(int *argp, struct svc_req *rqstp) {
    static result res;
    char* output = get_from_store(&r_store, *argp);
    res.id = *argp;
    if (output) {
        strcpy(res.output, output);
    } else {
        strcpy(res.output, "PENDING"); [cite: 56]
    }
    return &res;
}

// Override main to start threads
int main(int argc, char **argv) {
    init_queue(&t_queue);
    init_store(&r_store);
    
    pthread_t workers[3]; [cite: 51]
    for(int i=0; i<3; i++) pthread_create(&workers[i], NULL, worker_thread, NULL);
    
    // Standard RPC setup usually generated by rpcgen, but we must call it
    extern void taskprog_1(struct svc_req *rqstp, SVCXPRT *transp);
    register_rpc_progs(); // Note: Simplified for brevity
    svc_run(); 
    return 0;
}
